#!/usr/bin/env bash

base_dir=/var/vcap

if [[ $EUID -eq 0 ]]
then
  mkdir -p ${base_dir}
  chmod 777 ${base_dir}
  exit 1
else
  sudo mkdir -p ${base_dir}
  sudo chmod 777 ${base_dir}
fi

cd $(dirname $0)/..
release_path=$(pwd)
scripts=${release_path}/scripts

# preserve env variables
gem_home=$GEM_HOME; bundle_gemfile=$BUNDLE_GEMFILE; rubyopt=$RUBYOPT


# iterate over sorted list of packages to install from `packages_to_install` script
for package in $(${scripts}/helpers/packages_to_install)
do
  package_version=$(${scripts}/helpers/dev_package_version ${package})
  
  # agent's compile_package#start sequence:
  # - install_dependencies
  # - get_source_package (store at /var/vcap/data/compile/tmp/BLOBSTORE_ID)
  # - unpack_source_package (into compile_dir)
  # - compile
  # - pack
  # - upload
  #
  # variables/methods in agent's compile_package.rb
  # @base_dir     = /var/vcap
  # @compile_base = @base_dir/data/compile
  # compile_dir   = @compile_base/@package_name
  #               = /var/vcap/data/compile/@package_name
  # @install_base = @base_dir/data/packages
  # install_dir   = @install_base/@package_name/@package_version
  #               = /var/vcap/data/packages/@package_name/@package_version
  # @source_file  = @compile_base/tmp/BLOBSTORE_ID
  #               = /var/vcap/data/compile/tmp/BLOBSTORE_ID
  # compiled_package = @source_file.compiled
  #                  = /var/vcap/data/compile/tmp/BLOBSTORE_ID.compiled
  
  
  # local-only sequence here:
  # * install every package in order of dependencies
  #   - get source package
  #   - unpack source package
  #   - compile
  #   - pack & store (as part of hand-off to agent's job_install sequence)
  #
  # source_file = .dev_builds/packages/$package/$package_version.tgz
  # compiled_packages will go into:
  #   /var/vcap/data/packages/compiled/$package/$package_version.compiled
  
  # During script/configure (agent job_install), the packages will be
  # re-installed by the agent (library) from the packed blobs

  unset GEM_HOME; unset BUNDLE_GEMFILE; unset RUBYOPT
  compile_base=${base_dir}/data/compile
  install_base=${base_dir}/data/packages
  export BOSH_COMPILE_TARGET=${compile_base}/${package}
  export BOSH_INSTALL_TARGET=${install_base}/${package}/${package_version}
  
  # compiled_packages will go into:
  #   /var/vcap/data/packages/compiled/$package/$package_version.compiled
  compiled_package_path=/var/vcap/data/compiled_packages/${package}
  mkdir -p ${compiled_package_path}
  compiled_package="${compiled_package_path}/${package_version}.compiled"
  
  
  # skip compilation if compiled_package blob exists
  if [[ -f ${compiled_package} ]]
  then
    echo Skipping ${package} ${package_version}, already compiled.
  else
    echo Unpack source package ${package} ${package_version}...

    rm -rf ${BOSH_COMPILE_TARGET}
    mkdir -p ${BOSH_COMPILE_TARGET}
    rm -rf ${BOSH_INSTALL_TARGET}
    mkdir -p ${BOSH_INSTALL_TARGET}

    cd ${BOSH_COMPILE_TARGET}
    # - get source package (reference from .dev_builds)
    # - unpack source package
    tar -zxf ${release_path}/.dev_builds/packages/${package}/${package_version}.tgz 2>&1

    ls -al packaging
    
    echo Compiling package ${package} ${package_version}...
    # - compile
    if [[ -f packaging ]]; then
      bash -x packaging 2>&1 || exit 1
    fi

    echo Pack to ${compiled_package}
    # - pack & store
    # compiled_packages will go into:
    #   /var/vcap/data/packages/compiled/$package/$package_version.compiled
    cd ${BOSH_INSTALL_TARGET}
    tar -zcf ${compiled_package} .

    # setup versionless symlinks
    #   /var/vcap/data/packages/ruby/0.X-dev -> /var/vcap/packages/ruby
    mkdir -p ${base_dir}/packages
    rm -rf ${base_dir}/packages/${package}
    ln -s ${BOSH_INSTALL_TARGET} ${base_dir}/packages/${package}
  fi
  
  cd ${release_path}
done

# restore env variables
GEM_HOME=$gem_home; BUNDLE_GEMFILE=$bundle_gemfile; RUBYOPT=$rubyopt
