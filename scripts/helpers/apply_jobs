#!/usr/bin/env ruby

# AIM: Install each job (and its packages, if not already installed) as if each being applied to own VM

# Render the templates in your local release (job_path) into your /var/vcap/data/jobs (job_install_path)
# Any properties required by templates should be passed via a manifest file (manifest_path)
release_tgz      = ARGV.shift
job_path         = ARGV.shift
job_install_path = ARGV.shift
manifest_path    = ARGV.shift

base_dir = ENV['BASE_DIR'] || '/var/vcap'

def error_usage; $stderr.puts "USAGE: apply_jobs RELEASE_TGZ RELEASE_JOB_PATH JOB_INSTALL_PATH [MANIFEST_PATH]"; exit 1; end
def error_path_invalid(field); $stderr.puts "ERROR: Path #{field} does not exist"; error_usage; end

error_usage unless job_install_path
error_path_invalid('RELEASE_TGZ') unless File.exist?(release_tgz)
error_path_invalid('RELEASE_JOB_PATH') unless File.exist?(job_path)
error_path_invalid('JOB_INSTALL_PATH') unless File.exist?(job_install_path)

require "yaml"
require "erb"

ENV["BUNDLE_GEMFILE"] = "/bosh/agent/Gemfile"
require "rubygems"
require "webmock"
include WebMock::API

require "bundler/setup"
$:.unshift("/bosh/agent/lib")
require "agent"

if manifest_path
  error_path_invalid('MANIFEST_PATH') unless File.exist?(manifest_path)
  job_manifest = YAML.load_file(manifest_path)
end
job_manifest ||= {
  "properties" => {
    "description" => "Custom Description for app"
  }
}
# job_MF = YAML.dump(job_manifest)

release_name = "rackapp"

latest_dev_release_path = `ls -ct dev_releases/*-dev.yml`.lines.first.strip
latest_dev_release = YAML.load_file(latest_dev_release_path)
jobs = latest_dev_release["jobs"]
release_version = latest_dev_release["version"]

# Create spec of all packages to be installed by all jobs
#
# In normal bosh, a job would depend on a subset of packages
# During agent #job_install, only those subset of packages would be installed
# and any other already-installed packages would be removed
#
# Because of the removal step, we will tell the agent to install
# all packages for all jobs.
#
# As there is no blobstore, we stub the HTTP request to the blobstore
# to return the compiled_package blob; using webmock's #stub_request
packages_spec = {}
# For each package, add the latest compiled_package; e.g.
# {
#   "common" => { "name" => "common", "version" => "0.2-dev", "sha1" => Digest::SHA1.file(package_common_tgz).hexdigest, "blobstore_id" => "package_common_blobstore" }
# }
compiled_packages_path="#{base_dir}/data/compiled_packages/"
Dir[compiled_packages_path + "*"].each do |compiled_package_path|
  p compiled_package_path
  latest_compiled_package = `ls -ct #{compiled_package_path}/*.compiled`.lines.first.strip
  p latest_compiled_package
  latest_compiled_package =~ %r{/([^/]+).compiled} # find "0.5-dev" within "...packages/compiled/some-package/0.5-dev.compiled"
  name              = File.basename(compiled_package_path)
  version           = $1
  sha1              = Digest::SHA1.file(latest_compiled_package).hexdigest
  fake_blobstore_id = "compiled_package_#{name}"
  packages_spec[name] = {
    "name" => name,
    "version" => version,
    "sha1" => sha1,
    "blobstore_id" => fake_blobstore_id
  }
  stub_request(:get, "http://resources/#{fake_blobstore_id}?").to_return(:body => File.read(latest_compiled_package))
end

jobs.each do |job|
  job_tgz = ".dev_builds/jobs/#{job['name']}/#{job['version']}.tgz"
  compiled_package_common = ".dev_builds/packages/common/0.2-dev.tgz"
  job_sha1 = Digest::SHA1.file(job_tgz).hexdigest
  
  # +job+ contains:
  # - name: app
  #   version: 0.2-dev
  #   sha1: b53fb0cb1bea8a13e4a51b273c17371a16d3918d
  
  # required for spec: name template version sha1 blobstore_id
  apply_job_spec = job.merge({
    "template" => job["name"],
    "blobstore_id" => "job_app_blobstore"
  })
  
  # NOTE: the package blobs are assumed to be pre-compiled
  # FIXME: package_common_tgz IS NOT the .dev_builds tgz; rather the post-compiled tgz blob
  # IDEA: tarball up the outputs of scripts/install into tarballs
  
  apply_spec = {
    "deployment" => "rackapp",
    "release" => { "version" => release_version },
    "job" => apply_job_spec,
    "packages" => packages_spec,
    "configuration_hash" => "deadbeef"
  }.merge(job_manifest)

  Bosh::Agent::Config.base_dir = base_dir

  # setup taken from apply_spec.rb in bosh/agent
  Bosh::Agent::Config.setup({"logging" => { "file" => STDOUT, "level" => "DEBUG" }, "mbus" => nil, "blobstore_options" => {}})
  Bosh::Agent::Config.blobstore_provider = "simple"
  Bosh::Agent::Config.platform_name = "dummy"

  FileUtils.mkdir_p(File.join(base_dir, 'monit'))
  Bosh::Agent::Monit.setup_monit_user

  stub_request(:get, "http://resources/job_app_blobstore?").to_return(:body => File.read(job_tgz))


  Bosh::Agent::Message::Apply.process([apply_spec])
end