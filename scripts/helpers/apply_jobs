#!/usr/bin/env ruby

# AIM: Install each job (and its packages, if not already installed) as if each being applied to own VM

# Render the templates in your local release (job_path) into your /var/vcap/data/jobs (job_install_path)
# Any properties required by templates should be passed via a manifest file (manifest_path)
release_tgz      = ARGV.shift
job_path         = ARGV.shift
job_install_path = ARGV.shift
manifest_path    = ARGV.shift

base_dir = ENV['BASE_DIR'] || '/var/vcap'

def error_usage; $stderr.puts "USAGE: apply_jobs RELEASE_TGZ RELEASE_JOB_PATH JOB_INSTALL_PATH MANIFEST_PATH"; exit 1; end
def error_path_invalid(field); $stderr.puts "ERROR: Path #{field} does not exist"; error_usage; end

error_usage unless job_install_path
error_path_invalid('RELEASE_TGZ') unless File.exist?(release_tgz)
error_path_invalid('RELEASE_JOB_PATH') unless File.exist?(job_path)
error_path_invalid('JOB_INSTALL_PATH') unless File.exist?(job_install_path)
error_path_invalid('MANIFEST_PATH') unless File.exist?(manifest_path)

require "yaml"
require "erb"

ENV["BUNDLE_GEMFILE"] = "/bosh/agent/Gemfile"
require "rubygems"
require "webmock"
include WebMock::API

require "bundler/setup"
$:.unshift("/bosh/agent/lib")
require "agent"

begin
  job_manifest = YAML.load_file(manifest_path)
rescue ArgumentError => e
  $stderr.puts "Invalid YAML format for #{manifest_path}"
  $stderr.puts e
  exit 1
end

release_name = "rackapp" # TODO what is it?

latest_dev_release_path = `ls -t dev_releases/*-dev.yml`.lines.first.strip
latest_dev_release = YAML.load_file(latest_dev_release_path)
jobs = latest_dev_release["jobs"]
release_version = latest_dev_release["version"]

# Create spec of all packages to be installed by all jobs
#
# In normal bosh, a job would depend on a subset of packages
# During agent #job_install, only those subset of packages would be installed
# and any other already-installed packages would be removed
#
# Because of the removal step, we will tell the agent to install
# all packages for all jobs.
#
# As there is no blobstore, we stub the HTTP request to the blobstore
# to return the compiled_package blob; using webmock's #stub_request
packages_spec = {}
# For each package, add the latest compiled_package; e.g.
# {
#   "common" => { "name" => "common", "version" => "0.2-dev", "sha1" => Digest::SHA1.file(package_common_tgz).hexdigest, "blobstore_id" => "package_common_blobstore" }
# }
compiled_packages_path="#{base_dir}/data/compiled_packages/"
Dir[compiled_packages_path + "*"].each do |compiled_package_path|
  latest_compiled_package = `ls -t #{compiled_package_path}/*.compiled`.lines.first.strip
  latest_compiled_package =~ %r{/([^/]+).compiled$} # find "0.5-dev" within "...packages/compiled/some-package/0.5-dev.compiled"
  name              = File.basename(compiled_package_path)
  version           = $1
  sha1              = Digest::SHA1.file(latest_compiled_package).hexdigest
  fake_blobstore_id = "compiled_package_#{name}"
  packages_spec[name] = {
    "name" => name,
    "version" => version,
    "sha1" => sha1,
    "blobstore_id" => fake_blobstore_id
  }
  stub_request(:get, "http://resources/#{fake_blobstore_id}?").to_return(:body => File.read(latest_compiled_package))
end

jobs.each do |job|
  # if $package_version contains a decimal point, then its a dev build (.dev_builds),
  # else a finalized package
  job_version = job['version'].to_s
  build_folder = job_version =~ /dev/ ? '.dev_builds' : '.final_builds'
  job_tgz = "#{build_folder}/jobs/#{job['name']}/#{job['version']}.tgz"
  job_sha1 = Digest::SHA1.file(job_tgz).hexdigest
  
  # +job+ contains:
  # - name: app
  #   version: 0.2-dev
  #   sha1: b53fb0cb1bea8a13e4a51b273c17371a16d3918d
  
  # required for spec: name template version sha1 blobstore_id
  apply_job_spec = job.merge({
    "template" => job["name"],
    "version" => job_version,
    "blobstore_id" => "job_app_blobstore"
  })
  
  apply_spec = {
    "deployment" => "rackapp",
    "release" => { "version" => release_version },
    "job" => apply_job_spec,
    "packages" => packages_spec,
    "configuration_hash" => "deadbeef"
  }.merge(job_manifest)

  Bosh::Agent::Config.base_dir = base_dir

  # setup taken from apply_spec.rb in bosh/agent
  Bosh::Agent::Config.setup({"logging" => { "file" => STDOUT, "level" => "DEBUG" }, "mbus" => nil, "blobstore_options" => {}})
  Bosh::Agent::Config.blobstore_provider = "simple"
  Bosh::Agent::Config.platform_name = "dummy"

  FileUtils.mkdir_p(File.join(base_dir, 'monit'))
  Bosh::Agent::Monit.setup_monit_user

  stub_request(:get, "http://resources/job_app_blobstore?").to_return(:body => File.read(job_tgz))

  Bosh::Agent::Message::Apply.process([apply_spec])
end