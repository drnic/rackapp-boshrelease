#!/usr/bin/env ruby

# AIM: Install each job (and its packages, if not already installed) as if each being applied to own VM

# Render the templates in your local release (job_path) into your /var/vcap/data/jobs (job_install_path)
# Any properties required by templates should be passed via a manifest file (manifest_path)
release_tgz      = ARGV.shift
job_path         = ARGV.shift
job_install_path = ARGV.shift
manifest_path    = ARGV.shift

base_dir = ENV['BASE_DIR'] || '/var/vcap'

def error_usage; $stderr.puts "USAGE: apply_jobs RELEASE_TGZ RELEASE_JOB_PATH JOB_INSTALL_PATH [MANIFEST_PATH]"; exit 1; end
def error_path_invalid(field); $stderr.puts "ERROR: Path #{field} does not exist"; error_usage; end

error_usage unless job_install_path
error_path_invalid('RELEASE_TGZ') unless File.exist?(release_tgz)
error_path_invalid('RELEASE_JOB_PATH') unless File.exist?(job_path)
error_path_invalid('JOB_INSTALL_PATH') unless File.exist?(job_install_path)

require "yaml"
require "erb"

ENV["BUNDLE_GEMFILE"] = "/bosh/agent/Gemfile"
require "rubygems"
require "webmock"
include WebMock::API

require "bundler/setup"
$:.unshift("/bosh/agent/lib")
require "agent"

if manifest_path
  error_path_invalid('MANIFEST_PATH') unless File.exist?(manifest_path)
  job_manifest = YAML.load_file(manifest_path)
end
job_manifest ||= {
  "properties" => {
    "description" => "Custom Description for app"
  }
}
# job_MF = YAML.dump(job_manifest)

release_name = "rackapp"

latest_dev_release_path = `ls -ct dev_releases/*-dev.yml`.lines.first.strip
latest_dev_release = YAML.load_file(latest_dev_release_path)
jobs = latest_dev_release["jobs"]
release_version = latest_dev_release["version"]

jobs.each do |job|
  job_tgz = ".dev_builds/jobs/#{job['name']}/#{job['version']}.tgz"
  job_sha1 = Digest::SHA1.file(job_tgz).hexdigest
  
  # +job+ contains:
  # - name: rackapp
  #  version: 0.2-dev
  #  sha1: b53fb0cb1bea8a13e4a51b273c17371a16d3918d
  
  # required for spec: name template version sha1 blobstore_id
  apply_job_spec = job.merge({
    "template" => job["name"],
    "blobstore_id" => "job_blobstore_id"
  })
  
  apply_spec = {
    "deployment" => "rackapp",
    "release" => { "version" => release_version },
    "job" => apply_job_spec,
    # "packages" => {}, # package_specs ?
    "configuration_hash" => "deadbeef"
  }.merge(job_manifest)

  Bosh::Agent::Config.base_dir = base_dir
  # config_binding = Bosh::Agent::Util.config_binding(deployment_manifest)
  # job = Bosh::Agent::ApplyPlan::Job.new(valid_spec, config_binding)
  # job.install

  # plan = Bosh::Agent::ApplyPlan::Plan.new(spec)
  # plan.install_job
  # plan.configure_job
  # plan.install_packages ??

  # setup taken from apply_spec.rb in bosh/agent
  Bosh::Agent::Config.setup({"logging" => { "file" => STDOUT, "level" => "DEBUG" }, "mbus" => nil, "blobstore_options" => {}})
  Bosh::Agent::Config.blobstore_provider = "simple"
  Bosh::Agent::Config.platform_name = "dummy"

  FileUtils.mkdir_p(File.join(base_dir, 'monit'))
  Bosh::Agent::Monit.setup_monit_user

  # system_root = Bosh::Agent::Config.system_root
  # FileUtils.mkdir_p(File.join(system_root, 'etc', 'logrotate.d'))

  stub_request(:get, "http://resources/job_blobstore_id?").to_return(:body => File.read(job_tgz))


  Bosh::Agent::Message::Apply.process([apply_spec])
end