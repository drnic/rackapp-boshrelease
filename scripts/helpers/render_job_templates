#!/usr/bin/env ruby

# Render the templates in your local release (job_path) into your /var/vcap/data/jobs (job_install_path)
# Any properties required by templates should be passed via a manifest file (manifest_path)
job_path         = ARGV.shift
job_install_path = ARGV.shift
manifest_path    = ARGV.shift

def error_usage; $stderr.puts "USAGE: render_job_templates RELEASE_JOB_PATH JOB_INSTALL_PATH [MANIFEST_PATH]"; exit 1; end
def error_path_invalid(field); $stderr.puts "ERROR: Path #{field} does not exist"; error_usage; end
error_usage unless job_install_path

require "yaml"
require "erb"

error_path_invalid('RELEASE_JOB_PATH') unless File.exist?(job_path)
error_path_invalid('JOB_INSTALL_PATH') unless File.exist?(job_install_path)

manifest_yaml = if manifest_path
  error_path_invalid('MANIFEST_PATH') unless File.exist?(manifest_path)
  YAML.load_file(manifest_path)
else
  {"properties" => {}}
end

job_spec_yaml = YAML.load_file(File.join(job_path, "spec"))
job_spec_yaml["templates"].each_pair do |template, target|
  template_data = File.read(File.join(job_path, "templates", template))
  template = ERB.new(File.read(template_path))
  begin
    result = template.result(@config_binding)
  rescue Exception => e
    # We are essentially running an arbitrary code,
    # hence such a generic rescue clause
    line = e.backtrace.first.match(/:(\d+):/).captures.first
    install_failed("failed to process configuration template " +
                   "'#{src}': " +
                   "line #{line}, error: #{e.message}")
  end
end  